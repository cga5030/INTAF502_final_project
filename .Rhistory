}
# if calm
if (market>0.65 && market <= 0.75){
log_greturn_A <- rnorm(1, mean=0.01,  sd=0.01)   # gross return for asset A
log_greturn_B <- rnorm(1, mean=0.005, sd=0.001)  # gross return for asset B
log_greturn_C <- rnorm(1, mean=0.01,  sd=.01)    # gross return for asset C
}
# if cold
if (market>0.75 && market<1){
log_greturn_A <- rnorm(1, mean=-0.05, sd=0.03)   # gross return for asset A
log_greturn_B <- rnorm(1, mean=0.01,  sd=0.01)   # gross return for asset B
log_greturn_C <- rnorm(1, mean=0.04,  sd=0.01)   # gross return for asset C
}
exp(log_greturn_A)
#Case 2: Y=a+b*log(X)
X=runif(500,min=0.1,max=5)
logX=log(X)
Y=a+b*logX+rnorm(500,mean=0,sd=0.2)
mydata2=cbind(X,logX,Y)
plot(mydata2[,c("logX","Y")])
plot(mydata2[,c("X","Y")])
a=1
b=1
X=rnorm(500,mean=2,sd=1) #rnorm is a normal distribution generating random numbers
logY=a+b*X+rnorm(500,mean=0,sd=0.2)
Y=exp(logY)
mydata1=cbind(X,logY,Y) #cnimd means you combine everything together
plot(mydata1[,c("X","logY")])
plot(mydata1[,c("X","Y")])
X=runif(500,min=0.1,max=5)
logX=log(X)
Y=a+b*logX+rnorm(500,mean=0,sd=0.2)
mydata2=cbind(X,logX,Y)
plot(mydata2[,c("logX","Y")])
plot(mydata2[,c("X","Y")])
X=runif(500,min=0.1,max=5)
logX=log(X)
logY=a+b*logX+rnorm(500,mean=0,sd=0.2)
Y=exp(Y)
mydata3<-cbind(X,logX,Y,logY)
plot(mydata3[,c("logX","logY")])
plot(mydata3[,c("X","Y")])
# step 3: convert log gross returns to gross returns
greturn_A <- exp(log_greturn_A) # (USD)
greturn_B <- exp(log_greturn_B) # (USD)
greturn_C <- exp(log_greturn_C) # (USD)
asset_a*greturn_A
# step 4: calculate gain or loss
gain_or_loss_A <- asset_a - (asset_a*greturn_A)
gain_or_loss_A/asset_a*100
# step 4: calculate gain or loss
gain_or_loss_A <- (asset_a*greturn_A) - asset_a
# run some simulations
n <- 10 # number of monte carlo simulations
source('~/Elina_MonteCarlo.R')
View(gain_or_loss)
# run some simulations
n <- 10 # number of monte carlo simulations
gain_or_loss <- matrix(999,nrow=4,ncol=n)
View(gain_or_loss)
gain_or_loss[4,1] <- 'HOT'
View(gain_or_loss)
source('~/Elina_MonteCarlo.R')
View(gain_or_loss)
source('~/Elina_MonteCarlo.R')
View(gain_or_loss)
hist(gain_or_loss[4,])
gain_or_loss[4,]
totals <- gain_or_loss[4,]
totals
hist(totals)
plot(totals)
class(gain_or_loss)
totals <- as.numeric(gain_or_loss[4,])
hist(totals)
source('~/Elina_MonteCarlo.R')
hist(totals)
?quantile()
quantile(totals,probs=.05)
value_at_risk <- quantile(totals,probs=0.05)
value_at_risk
quantile(totals,probs=.5)
hist(as.numeric(gain_or_loss[1,]))
hist(as.numeric(gain_or_loss[2,]))
hist(as.numeric(gain_or_loss[3,]))
hist(totals, xlab="Gain or Loss (USD)") # produce a histogram for gains or losses
hist(totals, xlab="Gain or Loss (USD)") # produce a histogram for gains or losses
# Equation
m= 90 kg
# Equation
m = 90 kg
# Equation
m = 90
# Equation
m = 90 # kg
g = 9.8 # m/s²
A = 0.7 # m²
rho = 0.99 # kg/m^3
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
# Equation
m = 90 # kg
g = 9.81 # m/s²
A = 0.7 # m²
rho = 0.99 # kg/m^3
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
vt = sqrt((2*m*g)/(rho*A*Cd))
if(TRUE){
# Equation
m = 90 # kg
g = 9.81 # m/s²
A = 0.7 # m²
rho = 1.23 # kg/m^3
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
}
rho = (1.112+1.225)/2 # kg/m^3 # - we care about near-surface speeds
if(TRUE){
# Equation
m = 90 # kg
g = 9.81 # m/s²
A = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - we care about near-surface speeds
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
}
if(TRUE){
# Equation
m = 90 # kg
g = 9.81 # m/s²
A = 0.7 # m²
rho = .99 # kg/m^3 # - we care about near-surface speeds
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
}
if(TRUE){
# Equation
m = 90 # kg
g = 9.81 # m/s²
A = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
}
# Equation
m = 82+11 # kg human + parachute
m
m
if(TRUE){
# Belly-to-earth
m = 82 # kg human + parachute
g = 9.81 # m/s²
A = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
}
if(TRUE){
# Belly-to-earth
m = 93 # kg human + parachute
g = 9.81 # m/s²
A = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd = 1 # for belly-to-earth
vt = sqrt((2*m*g)/(rho*A*Cd))
}
if(TRUE){
# Belly-to-earth
m_human = 93 # kg human + parachute
g = 9.81 # m/s²
A_human = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_human = 1 # for belly-to-earth
vt_human = sqrt((2*m*g)/(rho*A*Cd))
}
if(TRUE){
# With chute
m_chute = 82+11 # kg human + parachute
g = 9.81 # m/s²
A_chute = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 1 # for belly-to-earth
vt_chute = sqrt((2*m*g)/(rho*A*Cd))
}
if(TRUE){
# With chute
m_chute = 82+11 # kg human + parachute
g = 9.81 # m/s²
A_chute = 19.51 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 1 # for belly-to-earth
vt_chute = sqrt((2*m*g)/(rho*A*Cd))
}
# Uncle Elon
rm(list=ls())
if(TRUE){
# Belly-to-earth
m_human = 93 # kg human
g = 9.81 # m/s²
A_human = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_human = 1 # for belly-to-earth
vt_human = sqrt((2*m_human*g)/(rho*A_human*Cd_human))
# With chute
m_chute = 82+11 # kg human + parachute
g = 9.81 # m/s²
A_chute = 19.51 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 1 # for belly-to-earth
vt_chute = sqrt((2*m_chute*g)/(rho*A_chute*Cd_chute))
}
if(TRUE){
# Belly-to-earth
m_human = 93 # kg human
g = 9.81 # m/s²
A_human = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_human = 1 # for belly-to-earth
vt_human = sqrt((2*m_human*g)/(rho*A_human*Cd_human))
# With chute
m_chute = 82+11 # kg human + parachute
g = 9.81 # m/s²
A_chute = 19.51 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 1.75 # for belly-to-earth
vt_chute = sqrt((2*m_chute*g)/(rho*A_chute*Cd_chute))
}
if(TRUE){
# Belly-to-earth
m_human = 93 # kg human
g = 9.81 # m/s²
A_human = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_human = 1 # for belly-to-earth
vt_human = sqrt((2*m_human*g)/(rho*A_human*Cd_human))
# With chute
m_chute = 82+11 # kg human + parachute
g = 9.81 # m/s²
A_chute = 19.51 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 1.9 # for belly-to-earth
vt_chute = sqrt((2*m_chute*g)/(rho*A_chute*Cd_chute))
}
if(TRUE){
# Belly-to-earth
m_human = 93 # kg human
g = 9.81 # m/s²
A_human = 0.7 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_human = 1 # for belly-to-earth
vt_human = sqrt((2*m_human*g)/(rho*A_human*Cd_human))
# With chute
m_chute = 82+11 # kg human + parachute
g = 9.81 # m/s²
A_chute = 19.51 # m²
rho = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 4 # for belly-to-earth
vt_chute = sqrt((2*m_chute*g)/(rho*A_chute*Cd_chute))
}
source('~/UncleElon.R')
source('~/UncleElon.R')
source('~/UncleElon.R')
source('~/UncleElon.R')
# On Mars
m_chute_mars = 82+11 # kg human + parachute
g_mars = 9.81 # m/s²
A_chute = 19.51 # m²
rho_mars = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 1.3 # for belly-to-earth
vt_chute_mars = sqrt((2*m_chute*g)/(rho*A_chute*Cd_chute))
source('~/UncleElon.R')
# On Mars
m_chute_mars = 82+11 # kg human + parachute
g_mars = 3.7 # m/s²
A_chute = 19.51 # m²
rho_mars = (1.112+1.225)/2 # kg/m^3 # - lowest 1000 km above surface
Cd_chute = 1.3 # for belly-to-earth
vt_mars = sqrt((2*m_chute*g)/(rho*A_chute*Cd_chute))
source('~/UncleElon.R')
source('~/UncleElon.R')
source('~/UncleElon.R')
source('~/UncleElon.R')
?anova()
rm(list=ls())
graphics.off()
library(ggplot2)
library(gridExtra)
library(ggpmisc)
# library(GGally)
# library(PerformanceAnalytics)
###############################################################
# A conflict-year dataset with information on armed conflict
# where at least one party is the government of a state in
# the time period 1946-2019.
load("data/ucdp-prio-acd-201.RData")
# Count by year
statedata <- ucdp_prio_acd_201
stateyears <- statedata$year
stateyears_unique <- sort(unique(statedata$year))
stateconflicts <- data.frame(matrix(999,ncol=2,nrow=length(stateyears_unique)))
stateconflicts[,1] <- stateyears_unique
names(stateconflicts) <- c("year","count")
for (n in 1:length(stateyears_unique)){
stateconflicts[n,2] <- sum(stateyears==stateyears_unique[n])
}
# # plot
# plot(x=stateconflicts$year,y=stateconflicts$count,
#      ylab = "global armed conflicts involving a state government",
#      xlab = "year")
# ggplot
stateplot  <-  ggplot(data=stateconflicts, aes(x=year, y=count)) +
geom_point() +
# theme(panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank()) +
ylab("Global armed conflicts (state)") + xlab("Year") +
geom_smooth()
# geom_smooth(aes(colour="LOESS"))+
# scale_colour_manual(name="legend", values=c("red"))
print(stateplot)
###############################################################
# A conflict-year dataset containing information on communal
# and organized armed conflict where none of the parties is
# the government of a state.
load("data/ucdp-nonstate-201.RData")
# Count by year
nonstatedata <- ucdp_nonstate_201
nonstateyears <- nonstatedata$year
nonstateyears_unique <- sort(unique(nonstatedata$year))
nonstateconflicts <- data.frame(matrix(999,ncol=2,nrow=length(nonstateyears_unique)))
nonstateconflicts[,1] <- nonstateyears_unique
names(nonstateconflicts) <- c("year","count")
for (n in 1:length(nonstateyears_unique)){
nonstateconflicts[n,2] <- sum(nonstateyears==nonstateyears_unique[n])
}
# plot
# plot(x=nonstateconflicts[,1],y=nonstateconflicts[,2],
#      ylab = "global armed conflicts involving no state government",
#      xlab = "year")
# ggplot
nonstateplot <- ggplot(data=nonstateconflicts, aes(x=year, y=count)) +
geom_point() +
# theme(panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank()) +
ylab("Global armed conflicts (non-state)") + xlab("Year") +
geom_smooth()
# geom_smooth(aes(colour="LOESS"))+
# scale_colour_manual(name="legend", values=c("red"))
print(nonstateplot)
##############################################################
# Global temperature anomaly from NASA
tempdata.in <- read.delim("data/temperature_anomaly.txt",sep="")
temps <- data.frame(matrix(999,ncol=2,nrow=length(tempdata.in$X1880)))
names(temps) <- c("year","temp")
temps[,1] <- tempdata.in$X1880
temps[,2] <- tempdata.in$X.0.16
# plot
# plot(x=temps[1,],y=temps[2,],
#      xlab = "year",
#      ylab = "mean temperature anomaly in deg C")
anomalyplot <-  ggplot(data=temps, aes(x=year, y=temp)) +
geom_point() +
# theme(panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank()) +
ylab("Mean global temperature anomaly [deg C]") + xlab("Year") +
geom_smooth()
# geom_smooth(aes(colour="LOESS"))+
# scale_colour_manual(name="legend", values=c("red"))
print(anomalyplot)
##############################################################
# Correlation between temperature anomaly and state conflicts
# line up the years
begyear <- stateconflicts$year[1]
endyear <- stateconflicts$year[length(stateconflicts$year)]
statetemps = subset(temps, year>=begyear&year<=endyear) # trim to desired years
statecor <- cor.test(x=stateconflicts$count,y=statetemps$temp
,method="pearson", exact=FALSE)
# pearson's correlation
stateplotdata <- stateconflicts
stateplotdata$temps <- statetemps$temp
stateplotdata <- subset (stateplotdata, select = -year)
##############################################################
# Correlation between temperature anomaly and state conflicts
# line up the years
begyear <- nonstateconflicts$year[1]
endyear <- nonstateconflicts$year[length(nonstateconflicts$year)]
nonstatetemps = subset(temps, year>=begyear&year<=endyear) # trim to desired years
# pearson's correlation
nonstatecor <- cor.test(x=nonstateconflicts$count,y=nonstatetemps$temp
,method="pearson", exact=FALSE)
nonstateplotdata <- nonstateconflicts
nonstateplotdata$temps <- nonstatetemps$temp
nonstateplotdata <- subset (nonstateplotdata, select = -year)
setwd("D:/Documents/GRAD SCHOOL/1 - SPRING 2021/INTAF 502/final project/INTAF502_final_project")
rm(list=ls())
graphics.off()
library(ggplot2)
library(gridExtra)
library(ggpmisc)
# library(GGally)
# library(PerformanceAnalytics)
###############################################################
# A conflict-year dataset with information on armed conflict
# where at least one party is the government of a state in
# the time period 1946-2019.
load("data/ucdp-prio-acd-201.RData")
# Count by year
statedata <- ucdp_prio_acd_201
stateyears <- statedata$year
stateyears_unique <- sort(unique(statedata$year))
stateconflicts <- data.frame(matrix(999,ncol=2,nrow=length(stateyears_unique)))
stateconflicts[,1] <- stateyears_unique
names(stateconflicts) <- c("year","count")
for (n in 1:length(stateyears_unique)){
stateconflicts[n,2] <- sum(stateyears==stateyears_unique[n])
}
# # plot
# plot(x=stateconflicts$year,y=stateconflicts$count,
#      ylab = "global armed conflicts involving a state government",
#      xlab = "year")
# ggplot
stateplot  <-  ggplot(data=stateconflicts, aes(x=year, y=count)) +
geom_point() +
# theme(panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank()) +
ylab("Global armed conflicts (state)") + xlab("Year") +
geom_smooth()
# geom_smooth(aes(colour="LOESS"))+
# scale_colour_manual(name="legend", values=c("red"))
print(stateplot)
###############################################################
# A conflict-year dataset containing information on communal
# and organized armed conflict where none of the parties is
# the government of a state.
load("data/ucdp-nonstate-201.RData")
# Count by year
nonstatedata <- ucdp_nonstate_201
nonstateyears <- nonstatedata$year
nonstateyears_unique <- sort(unique(nonstatedata$year))
nonstateconflicts <- data.frame(matrix(999,ncol=2,nrow=length(nonstateyears_unique)))
nonstateconflicts[,1] <- nonstateyears_unique
names(nonstateconflicts) <- c("year","count")
for (n in 1:length(nonstateyears_unique)){
nonstateconflicts[n,2] <- sum(nonstateyears==nonstateyears_unique[n])
}
# plot
# plot(x=nonstateconflicts[,1],y=nonstateconflicts[,2],
#      ylab = "global armed conflicts involving no state government",
#      xlab = "year")
# ggplot
nonstateplot <- ggplot(data=nonstateconflicts, aes(x=year, y=count)) +
geom_point() +
# theme(panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank()) +
ylab("Global armed conflicts (non-state)") + xlab("Year") +
geom_smooth()
# geom_smooth(aes(colour="LOESS"))+
# scale_colour_manual(name="legend", values=c("red"))
print(nonstateplot)
##############################################################
# Global temperature anomaly from NASA
tempdata.in <- read.delim("data/temperature_anomaly.txt",sep="")
temps <- data.frame(matrix(999,ncol=2,nrow=length(tempdata.in$X1880)))
names(temps) <- c("year","temp")
temps[,1] <- tempdata.in$X1880
temps[,2] <- tempdata.in$X.0.16
# plot
# plot(x=temps[1,],y=temps[2,],
#      xlab = "year",
#      ylab = "mean temperature anomaly in deg C")
anomalyplot <-  ggplot(data=temps, aes(x=year, y=temp)) +
geom_point() +
# theme(panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank()) +
ylab("Mean global temperature anomaly [deg C]") + xlab("Year") +
geom_smooth()
# geom_smooth(aes(colour="LOESS"))+
# scale_colour_manual(name="legend", values=c("red"))
print(anomalyplot)
##############################################################
# Correlation between temperature anomaly and state conflicts
# line up the years
begyear <- stateconflicts$year[1]
endyear <- stateconflicts$year[length(stateconflicts$year)]
statetemps = subset(temps, year>=begyear&year<=endyear) # trim to desired years
statecor <- cor.test(x=stateconflicts$count,y=statetemps$temp
,method="pearson", exact=FALSE)
# pearson's correlation
stateplotdata <- stateconflicts
stateplotdata$temps <- statetemps$temp
stateplotdata <- subset (stateplotdata, select = -year)
##############################################################
# Correlation between temperature anomaly and state conflicts
# line up the years
begyear <- nonstateconflicts$year[1]
endyear <- nonstateconflicts$year[length(nonstateconflicts$year)]
nonstatetemps = subset(temps, year>=begyear&year<=endyear) # trim to desired years
# pearson's correlation
nonstatecor <- cor.test(x=nonstateconflicts$count,y=nonstatetemps$temp
,method="pearson", exact=FALSE)
nonstateplotdata <- nonstateconflicts
nonstateplotdata$temps <- nonstatetemps$temp
nonstateplotdata <- subset (nonstateplotdata, select = -year)
# state
statecordata <- stateconflicts
statecordata[,3] <- statetemps$temp
names(statecordata) <- c("year","conflicts","temps")
linear_state <- lm(conflicts~temps,data=statecordata) # linear regression
summary(linear_state)
anova(linear_state)
source('D:/Documents/GRAD SCHOOL/1 - SPRING 2021/INTAF 502/final project/INTAF502_final_project/final_project.R', echo=TRUE)
source('D:/Documents/GRAD SCHOOL/1 - SPRING 2021/INTAF 502/final project/INTAF502_final_project/final_project.R', echo=TRUE)
